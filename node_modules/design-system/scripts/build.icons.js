const fs = require('fs');
const mkdirp = require('mkdirp');
const path = require('path');
const SVGSprite = require('svg-sprite');

/* Utils */
const build = require('./build.utils');

/* Settings */
const spriteFileName = 'icons-sprite.symbol.svg';

const iconsDir = '../src/assets/icons';
const iconsPath = path.resolve(__dirname, iconsDir);

// Output
const outputPath =
  process.env.ICONS_OUTPUT_PATH || path.resolve(__dirname, `../dist`);
const iconsOutputPath = `${outputPath}/${spriteFileName}`;

// Sprite optimization
const svgoConfig = require('../svgo.config.json');
const spriteConfig = {
  dest: outputPath,
  mode: {
    inline: true,
    symbol: true
  },
  shape: {
    transform: [
      {
        svgo: svgoConfig
      }
    ]
  }
};

/**
 * Load icons list set based on environment
 * Production: `icons-sprite.config.json` subset
 * Development: `/src/assets/icons/
 */
function loadIconsSet() {
  let list = [];

  if (build.isDev()) {
    list = fs.readdirSync(iconsPath).map(file => file.replace(/\.[^\.]+$/, ''));
  } else {
    list = require('../src/assets/icons-sprite.config.json');
  }

  return list;
}

/**
 * Add icons to svg source files to sprite prior compilation
 * @param {SVGSprite Instance} sprite
 */
function addIconFiles(sprite) {
  const iconList = loadIconsSet();

  for (icon of iconList) {
    const iconPath = path.resolve(__dirname, `${iconsDir}/${icon}.svg`);

    try {
      sprite.add(
        iconPath,
        null,
        fs.readFileSync(iconPath, { encoding: 'utf-8' })
      );
      build.cLog(`added: ${icon}`, 'success');
    } catch (error) {
      build.cLog(`skipping: ${icon} --> file not found: ${iconPath}`);
    }
  }
}

/**
 * Outputs svg contents after it got compiled by svgo
 *
 * @param {Error} error Error message in case the compilation has failed
 * @param {Object} result Directory of generated resources
 */
function processCompile(error, result) {
  if (error) {
    throw new Error(error);
  }

  try {
    for (let mode in result) {
      for (let resource in result[mode]) {
        const isIconSprite = resource === 'sprite';
        (isIconSprite ? iconsOutput : genericOutput)(result[mode][resource]);
      }
    }
  } catch (error) {
    throw new Error(error);
  }
}

/**
 * Writes file in icons custom output path
 * @param {File} file
 */
function iconsOutput(file) {
  mkdirp.sync(outputPath);
  fs.writeFileSync(iconsOutputPath, file.contents);
}

/**
 * Writes file using sprite's default output config
 * @param {File} file
 */
function genericOutput(file) {
  mkdirp.sync(path.dirname(file.path));
  fs.writeFileSync(file.path, file.contents);
}

/**
 * Compiles svg sprite sheet
 */
function compileSprite() {
  build.logger('Building icons sprite', '[Started]', 'Adding SVG sources');

  const SVG = new SVGSprite(spriteConfig);
  addIconFiles(SVG);
  SVG.compile(processCompile);

  build.logger(
    'Building icons sprite',
    '[Finished]',
    build.cLog(`Check: ${iconsOutputPath}`, 'info')
  );
}

/* Compile SVG Sprite */
compileSprite();
