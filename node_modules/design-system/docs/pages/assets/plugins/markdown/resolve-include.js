const path = require('path');
const fs = require('fs');
const yaml = require('js-yaml');
const pug = require('pug');

// matches !!!include(*.*)!!!
// ie. !!!include(filename.(md|pug))!!!
const INCLUDE_REGEXP = /\!{3}\s*include\s*\(\s*(.+?)\s*\)\s*\!{3}/i;
const allowedExtensions = ['.md', '.pug'];
const allowedSrcExtensions = ['.yml'];

// wraps error messages
const wrapError = err => {
  return `ERROR in [INCLUDE_PLUGIN]: \n ${err}`;
};

// prints help template message
const errorHelpBlock = (fileName, hint = '') => `
  ---
  title: ...
  template: *.pug
  sources: [ ${fileName} ] <--- ${hint ? hint : ''}
  ---
`;

module.exports = function include(md, settings = {}) {
  const defaultSettings = { root: '.', regExp: INCLUDE_REGEXP };
  const options = Object.assign({}, defaultSettings, settings);

  function replacePartialIncludeByContent(
    src,
    rootDir,
    parentFilePath,
    filesProcessed
  ) {
    filesProcessed = filesProcessed ? filesProcessed.slice() : [];
    let cap, filePath, partialSrc, indexOfCircularRef;

    // store parent file path to check circular references
    if (parentFilePath) {
      filesProcessed.push(parentFilePath);
    }
    while ((cap = options.regExp.exec(src))) {
      filePath = path.resolve(rootDir, cap[1].trim());
      console.log('cap: ', cap);

      // check if circular reference
      indexOfCircularRef = filesProcessed.indexOf(filePath);
      if (indexOfCircularRef !== -1) {
        const circRefPath = filesProcessed[indexOfCircularRef];
        throw new Error(
          wrapError(`Circular reference between ${filePath} and ${circRefPath}`)
        );
      }

      // check file extension
      const extname = path.extname(filePath);
      if (!allowedExtensions.includes(extname)) {
        throw new Error(
          wrapError(
            `Extension '${extname}' is not supported. \n Allowed extensions: '${allowedExtensions.toString()}'`
          )
        );
      }

      // attempt to load partial file content
      try {
        partialSrc = fs.readFileSync(filePath, 'utf8');
      } catch (err) {
        throw new Error(
          wrapError(
            `Source: ${options.fileName} -> ${cap[0]} \n Error: No such file '${
              cap[1]
            }' \n ${err}`
          )
        );
      }

      // attempt to load partial sources from .yml files
      const sources = {};
      let lastSourceName;
      if (options.metadata.sources) {
        try {
          options.metadata.sources.forEach(fileName => {
            lastSourceName = fileName; // catch fileName for errors

            // validate source extension
            const ext = path.extname(fileName);
            if (!allowedSrcExtensions.includes(ext)) {
              throw new Error(
                `Extension '${ext}' is not supported for sources. Allowed extensions: '${allowedSrcExtensions.toString()}'`
              );
            }

            const content = yaml.safeLoad(
              fs.readFileSync(path.resolve(rootDir, fileName), 'utf8')
            );

            const key = fileName.replace(path.extname(fileName), '');
            sources[key] = content;
          });
        } catch (error) {
          throw new Error(
            wrapError(
              `Source: ${options.fileName} -> ${
                cap[0]
              } \n Error: Invalid source '${lastSourceName}' in '${rootDir}' \n ${errorHelpBlock(
                lastSourceName
              )} \n ${error}`
            )
          );
        }
      }

      // Render content from .pug template
      if (extname === '.pug') {
        partialSrc = pug.render(partialSrc, { sources });
      }

      // Recursively resolve internal partials content
      partialSrc = replacePartialIncludeByContent(
        partialSrc,
        path.dirname(filePath),
        filePath,
        filesProcessed
      );

      // Append partial rendered content to parent src
      src = `${src.slice(0, cap.index)}${partialSrc}${src.slice(
        cap.index + cap[0].length,
        src.length
      )}`;
    }

    return src;
  }

  // Resolves partial content and appends it to state
  function includeFilePartials(state) {
    state.src = replacePartialIncludeByContent(state.src, options.root);
  }

  // Attach custom markdown-it rule
  md.core.ruler.before('normalize', 'include', includeFilePartials);
};
