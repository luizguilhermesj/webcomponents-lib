---
title: SCSS patterns & File organisation
template: doc.pug
---

## SCSS patterns

Source files are found at `src`. It contains style patterns meant to be in functional UI components.

[Note]: JS components support will come in the future, as in Q3/2019 version design system only provide CSS patterns.

SCSS patterns are implemented independent of any specific component implementation.

## File organization

The basic file structure will follow [ITCSS](https://www.xfive.co/blog/itcss-scalable-maintainable-css-architecture/) architecture.

ITCSS splits sass files into several layers, to ensure clear cascade inheritance and separation of concerns:

1.  Settings – Used with preprocessors and might contain wide use variables (font, colors, dimensions, z-index, etc).

2.  Tools – globally used mixins and functions.

> *!!* It’s important to notice, layers **1 -> 2** will not to output any CSS.

3.  Generic – reset and/or normalize styles, box-sizing definition, etc. This is the first layer that generates actual CSS.

4.  Elements – styling for bare HTML elements (like: h1, a, buttons, etc.). These come with default styling from the browser so it can redefine them here.

5.  Components – specific UI components. place UI components that are often composed of elements and other components.

6.  Utilities – utilities and helper classes with the ability to strongly override anything in previous layers. (like: `.visually-hidden` helper class). `important!` CSS rules are allowed here but discouraged in any other layer above.

!! It’s important to notice, layers 3 -> 6 can output CSS classes.

*Note:* ITCSS `objects` layer is not being used since it doesn't fit into this project approach.

## Molecule Structure

Each ITCSS layer in the Design system, contains molecules, those are regularly composed from 2 to 3 types of files a `core`, and `output` and an `entry point`.

* core: A core file stores a molecule implementation, it has `mixins/functions/variables` as well as `imports` to other molecules files or utilities.
* output: An output file stores a molecule CSS class definition. It means is where you define CSS selectors, that use the core implementation.
* entry point: An entry point is usually a kind of `index.scss` file. That will export several parts of a molecule as one.

**Example:**

The following tree shows a button molecule structure:

```bash
   src
   ├── element
   │   ├── buttons
   │   │   ├── _buttons.scss # output: classes & selectors
   │   │   ├── _buttons-core.scss # core: mixins & imports.
   │   │   └── README.md
   ├── elements.scss # entry point for `element` molecule, it exports all elements as one
   └── README.md
```

**[Notice, that]:**
* all molecule files are sass [partials](https://sass-lang.com/documentation/at-rules/import#partials), that means they are prefix by an underscore `_buttons`.
* output files name is just a molecule's name: (_button.scss).
* core files have do have a `core` postfix, as in `_{molecule}-core`: (_button-core.scss).


## Structuring core and output for any molecule core:

### Naming style

Mostly apply `[C]CTI` reasoning when defining names for variables. When it comes to naming `mixins` please consider:

### selectors & @mixin organisation

Let us run through it with an example, shall we?:

1. We are creating styles for a button element
2. We start by declaring is styles

```scss
.button {
   color: $color-text-base;
   background-color: $color-background-base;

   &--disabled {
      color: $color-text-disabled;
      background-color: $color-background-disabled;
   }

   &--active {
      color: $color-text-active;
      background-color: $color-background-active;
   }

   &--primary {
      color: $color-text-primary-base;
      background-color: $color-background-primary-base;

      &--active {
         color: $color-text-primary-base;
         background-color: $color-background-primary-base;
      }

      &--disabled {
         color: $color-text-primary-base;
         background-color: $color-background-primary-base;
      }
   }
}
```

3. If we take an x-ray at is structure, we can isolate `selectors` from `styles`, resulting in a pattern like:

```scss
   .button {
      /*...button styles */
      &--active {/*...button active styles */}
      &--disabled {/*..button disabled styles */}
      
      &--primary {
         /*...button primary styles */
         &--active {/*.../*...button primary active styles */*/}
         &--disabled {/*...button primary disabled styles*/}
      }
   }
```

4. Finally, the last thing we need to do is to create a core file to group all `styles` as mixins. And, from there apply/compose each individually:

```scss
   // _button-core.scss
   @mixin button-base {
      color: $color-text-base;
      background-color: $color-background-base;
   }
   /* ... an so on for other styles */

   // _button.scss
   @import './buttons-core';

   .button {
      @include button-base;

      &--active {
         @include button-active;
      }
      &--disabled {
         @include button-disabled;
      }
      
      &--primary {
         @include button-primary;
         
         &--active {
            @include button-primary-active;
         }
         &--disabled {
            @include button-primary-disabled;
         }
      }
   }
```

5. And there you go, as the final result you got:
   * `output` and `core` files for buttons
   * independent styles properties, this organization will allow you to create as many output versions with a different format as required from the same core styles.

## FAQ

### Why do we do have a separate `core` and `output` scss files?
It is for several reasons as:

* Cross system compatibility: Some systems follow BEM when defining classes, some others `(like Alice)` don't. By keeping `core` separate from `output` we don't need to force those systems to migrate, but instead to create its own output version from the `core`. This will enforce consistency from the core since all systems will consume the same styles but in different ways.

* Maintenance: Allows easier/quicker code refactoring. Because sass is modular and not a single file to be replaced. Also, other systems can consume each layer individually, reducing the chances of getting affected by global breaking changes.

### Why don't we pass down parameters to core mixins?

It is not mandatory to not pass down parameters to core @mixins. We actually have mixins that are complex and change output styles based on given parameters.

For instance:

```scss
.button {
   @include button-primary; // 1. 
   // vs
   @include button-base($type: primary); // 2.
}
```
Nevertheless, we recommend you to favor explicitness (`1`) over complexity (`2`). So it is your choice to do go with `1 or 2`.

In short, `1` is for most cases, `2` when styles logic is complex and meant to be done once.

To choose which please consider:

* `1` definition is simpler as it only and always output styles for `type: primary`
* `2` definition is wider, as it requires logic to switch through other styles for (secondary, tertiary, etc...). It produces many outputs.
* When it comes to refactoring `1` scope is a single type to affect, whereas `2` affects all other button types.
* When it comes to complexity, `1` might just have some styles to add/remove, but `2` requires an upfront understanding of its behavior (proceed with care).
* When it comes to explicitness, `1` has a single concern `primary` button and not many like in `2`.
* Finally, `2` is a better option when the output styles are complex and hard to map. Therefore, are better to be implemented once. For instance when mapping variables in maps or doing complex math around variables. (ie: `@mixin button-scheme`)
